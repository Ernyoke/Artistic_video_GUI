\documentclass[12pt, a4paper, oneside]{book}

%---------------------------------------------------------   
\usepackage[english,romanian,magyar]{babel}       
\usepackage[utf8]{inputenc}
\usepackage[a4,center,axes]{crop}
\usepackage{calc}
\usepackage{t1enc}
\usepackage{amsthm}
\usepackage{rotating}
\usepackage{amssymb}
\usepackage{lscape}
\usepackage{anysize}
\usepackage{setspace} 
\usepackage{comment}
\usepackage{graphicx}
\usepackage{setspace} 
\usepackage{tocloft}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage[top=3cm, bottom=2cm, left=3cm, right=2cm]{geometry}

%---------------------------------------------------------
%%
%%
%% alapformázások
%%
%%
\sloppy                        % sorkizárás kezelése
\clubpenalty = 10000           % árvasorok
\widowpenalty = 10000          % fatyúsorok
\raggedbottom                  % függõleges kizárás az oldalon
\setcounter{secnumdepth}{3}    % alcimek számozási mélysége
\setcounter{tocdepth}{3}       % tartalomjegyzék mélysége
\brokenpenalty = 10000         % lap aljai elválasztások tiltása
\doublehyphendemerits = 80000  % egymást követõ elválasztások

%\marginsize{2cm}{2cm}{2cm}{2cm} %marók beállítása
\onehalfspacing %sorközök megaddása

\theoremstyle{tetel}
\newtheorem{mydef}{értelmezés}[chapter]
\newtheorem{megj}{megjegyzés}[chapter]

\def\partro#1{\foreignlanguage{romanian}{\addcontentsline{tro}{part}{%\if@mainmatter\protect\numberline{\thechapter.}\fi
\MakeUppercase{#1}}}}
\def\chapterro#1{\foreignlanguage{romanian}{\addcontentsline{tro}{chapter}{\if@mainmatter\protect\numberline{\thechapter.}\fi#1}}}
\def\sectionro#1{\foreignlanguage{romanian}{\addcontentsline{tro}{section}{\protect\numberline{\thesection.}#1}}}
\def\subsectionro#1{\foreignlanguage{romanian}{\addcontentsline{tro}{subsection}{\protect\numberline{\thesubsection.}#1}}}
\def\subsubsectionro#1{\foreignlanguage{romanian}{\addcontentsline{tro}{subsubsection}{\protect\numberline{\thesubsubsection.}#1}}}

%roman tartalom def
%---------------------------------------------------------
\newcommand{\nombreindice}{Cuprins}
\newlistof{indice}{tce}{\nombreindice}

\newcommand\capterro[1]{%
	\addcontentsline{tce}{chapter}{\protect\makebox[1.3em][l]{\thechapter.}#1}}
\newcommand\secro[1]{%
	\addcontentsline{tce}{section}{\protect\makebox[2.8em][l]{\thesection.}#1}}
\newcommand\ssecro[1]{%
	\addcontentsline{tce}{subsection}{\protect\makebox[3em][l]{\thesubsection.}#1}}
\newcommand\sssecro[1]{%
	\addcontentsline{tce}{subsubsection}{\protect\makebox[3em][l]{\thesubsubsection.}#1}}

%angol tartalom def
%---------------------------------------------------------

\newcommand{\tcontents}{Table Of Contents}
\newlistof{indiceen}{tcen}{\tcontents}

\newcommand\capteren[1]{%
	 \addcontentsline{tcen}{chapter}{\protect\makebox[1.3em][l]{\thechapter.}#1}}
\newcommand\secen[1]{%
	 \addcontentsline{tcen}{section}{\protect\makebox[2.8em][l]{\thesection.}#1}}
\newcommand\ssecen[1]{%
	\addcontentsline{tcen}{subsection}{\protect\makebox[3em][l]{\thesubsection.}#1}}
\newcommand\sssecen[1]{%
	\addcontentsline{tcen}{subsubsection}{\protect\makebox[3em][l]{\thesubsubsection.}#1}}

%---------------------------------------------------------
\newcommand*{\field}[1]{\mathbb{#1}}

%---------------------------------------------------------

%---------------------------------------------------------
\begin{document}
\pagenumbering{arabic}

%magyar borito
%--------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
    \Large SAPIENTIA ERDÉLYI MAGYAR TUDOMÁNYEGYETEM\\
    \Large MŰSZAKI ÉS HUMÁNTUDOMÁNYOK KAR, MAROSVÁSÁRHELY\\
    \Large SZOFTVERFEJLESZTÉS SZAK\\
\end{center}

\begin{center}
 	\vspace{2cm}\LARGE \textbf{Párhuzamos képstílus átruházás konvolúciós neuronhálókkal}\\
	 \vspace{1cm}\LARGE \textbf{MESTERI DISSZERTÁCIÓ}\\
\end{center}

\vspace{2cm}
\begin{figure}[htb]
\begin{center}
\includegraphics{sapientia_logo.png}
\end{center}
\end{figure}

\vspace{2cm}
\begin{center}
\begin{tabular}{lcccccccccccl}
    TÉMAVEZETŐ:&&&&&&& &&&&&SZERZŐ:\\
     dr. Iclănzan Dávid&&&&&& &&&&&&Szilágyi Ervin\\
	Egyetemi tanár
\end{tabular}
\end{center}

\begin{center}
    \vspace{0.5cm}\textbf{2017 Július}
\end{center}
\vspace*{\fill}
%roman borito
%-------------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
    %\Large UNIVERSITATEA BABE\c{S}-BOLYAI CLUJ-NAPOCA\\
    \Large UNIVERSITATEA SAPIENTIA TÂRGU-MURE\c{S}\\
    \Large FACULTATEA DE \c{S}TIIN\c{T}E TEHNICE \c{S}I UMANISTE\\
    \Large SPECIALIZAREA DEZVOLTARE DE SOFTWARE\\
\end{center}

\begin{center}
    \vspace{3cm}\LARGE \textbf{DeepArt}\\
    \vspace{1cm}\LARGE\textbf{Lucrare de master}\\
\end{center}

\vspace{2cm}
\begin{figure}[htb]
	\begin{center}
		\includegraphics{sapientia_logo.png}
	\end{center}
\end{figure}

\vspace{2cm}
\begin{center}
\begin{tabular}{lcccccccccccl}
    Coordonator \c{s}tiin\c{t}ific:&&&&&&& &&&&&Absolvent:\\
     dr. Iclănzan Dávid&&&&&& &&&&&&Szilágyi Ervin\\

\end{tabular}
\end{center}

\begin{center}
    \vspace{1cm}\textbf{2017 Iulie}
\end{center}

%angol borito
%-------------------------------------------------------------

\newpage
\thispagestyle{empty}
\begin{center}
    %\Large BABE\c{S}-BOLYAI UNIVERSITY CLUJ-NAPOCA\\
    \Large SAPIENTIA UNIVERSITY TÂRGU MURE\c{S}\\
    \Large FACULTY OF TECHNICAL AND HUMAN SCIENCES\\
    \Large SOFTWARE DEVELOPMENT SPECIALIZATION\\
\end{center}

\begin{center}
    \vspace{3cm}\LARGE \textbf{Parallel artistic style transfer using deep convolutional neural networks}\\
    \vspace{1cm}\LARGE \textbf{Master Thesis}\\
\end{center}

\vspace{2cm}
\begin{figure}[htb]
	\begin{center}
		\includegraphics{sapientia_logo.png}
	\end{center}
\end{figure}

\vspace{2cm}
\begin{center}
\begin{tabular}{lcccccccccccl}
     Advisor: & & &&&& &&&&&& Student:\\
     dr. Iclănzan Dávid &&&&&& &&&&&& Szilágyi Ervin\\
\end{tabular}
\end{center}

\begin{center}
    \vspace{1cm}\textbf{2017 July}
\end{center}

%eredetisegi nyilatkozat
%-------------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
	\textbf{Declaraţie}
\end{center}
\leavevmode
\\[2cm]
\indent
Subsemnata/ul ............................................................., absolvent(ă) al/a specializării ......................................, promoţia ................... cunoscând prevederile Legii Educaţiei Naţionale 1/2011 şi a Codului de etică şi deontologie profesională a Universităţii Sapientia cu privire la furt intelectual declar pe propria răspundere că prezenta lucrare de disertație se bazează pe activitatea personală, cercetarea/proiectarea este efectuată de mine, informaţiile şi datele preluate din literatura de specialitate sunt citate în mod corespunzător.
\newline
\\[7cm]
\indent
\begin{tabular}{lcccccccccccccccccl}
	Localitatea, & & &&&& &&&&&&&&&&&& Absolvent:\\
	Data: &&&&&& &&&&&&&&&&&&Semnătura..................\\
\end{tabular}


%kivonat magyar
%-------------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
    \Large KIVONAT
\end{center}

kivonat

\begin{flushright}
\textbf{Szilagyi Ervin,}\\
.........................
\end{flushright}

%kivonat roman
%-------------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
    \Large ABSTRACT
\end{center}

abstract

\begin{flushright}
\textbf{Szilagyi Ervin,}\\
.........................
\end{flushright}

%kivonat angol
%-------------------------------------------------------------
\newpage
\thispagestyle{empty}
\begin{center}
    \Large ABSTRACT
\end{center}

english abstract


\begin{flushright}
\textbf{Szilagyi Ervin,}\\
.........................
\end{flushright}

%tartalom jegyzek
%-------------------------------------------------------------
\newpage
\tableofcontents
\newpage
\listofindice
\newpage
\listofindiceen

\selectlanguage{magyar}

%-------------------------------------------------------------
\chapter{Bevezető}
\capterro{Întroducere}
\capteren{Indroduction}

Napjainkban a képfeldolgozás egy eléggé elterjedt kutatási terület. A kutatások célja főleg az információ kinyerésére, gépi látás kivitelezésére irányult. Minderre kiváló megoldást jelentett a mély konvolúciós hálók (ConvNets)\cite{1}\cite{2} sikeres használata növelve ezzel ezek népszerűségét. Fontos megjegyezni, hogy a konvolúciós neuron hálók felfedezése már pár évtizede történt, tehát maga a technológia már régebb ismert volt. Az újrafelfedezésüket és hirtelen népszerűség növekedését annak köszönhetik, hogy az utóbbi években olyan hardveres megoldások jelentek meg, amik lehetővé teszik az ilyen típusú hálók létrehozását és működtetését. 
\newline 
\indent
Az Nvidia cég 2007-ben bevezette az Nvidia CUDA platformot\cite{3}. Ez egy komoly, használható fejlesztő környezetett jelentett olyan fejlesztők számára akik nagy méretű adatpárhuzamos algoritmusokat szerettek volna fejleszteni. A CUDA környezet direkt elérhetőséget nyújt a videókártya utasításkészletéhez megengedve ezzel ennek a programozását. Ugyanakkor számos olyan videókártya került piacra ami egyre komolyabb számítási készségekkel bírt. Ezt a lehetőséget értelemszerűen a kutatók ki is használták így számos újabb publikáció és javaslat jelent meg amik neuron hálókat használnak az illető probléma megoldására.
\newline
\indent
A deep konvolúciós hálók népszerűségének növekedésével egyre több olyan fejlesztői környezet jelent meg amiknek célja a mesterséges intelligencia feladatok megoldása. Ilyen könyvtárak például a Caffe\cite{4}, Keras\cite{5}, Theano\cite{6}, Tensorflow\cite{7}, Torch\cite{8} stb. Ezek a környezetekben, habár különböző stílusban de egyazon problémákra hivatottak gyors és egyszerű megoldásokat ajánlja ugyanúgy mezei szoftverfejlesztők, mint kutatók számára.
\newline
\indent
Az gépi látás egyik fontos alkalmazási területe a képen levő tárgyak, élőlények emberek felismerése. Ilyen területen a konvolúciós hálók kimagasló teljesítményt nyújtanak, olyannyira, hogy egyes kisérletek szerint ez már nemhogy az emberi látással megegyező, hanem azt felülmúló teljesítményt nyújtanak\cite{9}. Feltevődik a kérdés, hogyha ennyire szofisztikált a gépi látás, akkor nem-e lehetne használni arra, hogy új képeket alkosson. Amint kiderült erre is alkalmasak. Az általam bemutatandó dolgozat is ezt a témát próbálja megcélozni. A gépi látás a tárgyak, élőlények mellett képes felismerni maga a kép művészeti stílusát. Ez elsősorban kihasználható arra, hogy híres művészek alkotásait csoportosítsuk, rendszerezzük\cite{10}, de amint e dolgozatból ki fog derülni, ki lehet használni arra is, hogy egy művészeti stílust egy adott festményről átvigyük egy mindennapi képre, fotóra. 
\newline
\indent
A dolgozatom célja magyar híres festőművészek festészeti stílusát átvenni és ezt alkalmazni mindennapi képekre illetve mozgóképekre. Eddigiekben, ahhoz hogy egy mindennapi fényképből művészeti képet varázsoljunk, képszerkesztő szoftverek segítségével lehetett elérni manuálisan. Mindezt egy olyan egyén végezhette, akinek képszerkesztési illetve képmanipulálási szakismere volt adott képszerkesztési szoftverkörnyezetben. Magától értődik az, hogy ez mozgóképek esetében egy időigényes folyamat. Dolgozatom mindezekre megoldást próbál adni, azáltal, hogy az általam elkészített szoftvert bárki használhatja, nincs szükség különböző képszerkesztői szakértelemre, emellett a folyamat ideje jelentősen csökkenni fog. 

%-------------------------------------------------------------
\chapter{Hasonló rendszerek feltérképezése}
\capterro{Studiu bibliografic}
\capteren{Bibliographic study}
A neuron hálók használata a számítástechnikában nem egy újonnan kialakult terület. Frank Rosenblatt 1958-ban publikált egy olyan mintafelismerő algoritmust\cite{11}, ami egyszerű összeadást és kivonást használva képes volt "tanulni". A rendszer képes volt finomhangolni állapotát a bekövetkező iterációk során. Ezt az algoritmust perceptronnak nevezzük. 1975-ben Paul Werbos bevezette a backpropagation algoritmust\cite{12}, amit a perceptronnal együtt használva megoldotta a perceptron azon problémáját miszerint az csak lineárisan elválasztható osztályokat volt képes kategorizálni. Habár a neuron hálók tanulmányozása eléggé ígéretesnek látszott, számítási igényük, komplexitásuk és lassú válasz idejük miatt a kutatók arra következtetésre jutottak, hogy a gyakorlatban még nem lehet alkalmazni őket.
\newline
\indent
Yann LeCun professzor és csapata 1998-ban egy újabb topológiájú hálót vezetett be\cite{13}. A LeNet-5 elnevezésű háló konvoluciós rétegeket is tartalmazott ezért konvolúciós neuron hálónak nevezzük. A publikáció célja kézzel írott számjegyek kategorizálása volt, létrehozva ezáltal a MNIST adatbázist, ami 60000 28x28-as felbontású kézzel írott számjegyet tartalmaz, emellett tartalmaz egy 10000 tagból álló teszthalmazt. A dolgozatban bemutatott LeNet-5 háló 0,7\%-os hiba aránnyal volt képes kategorizálni a számjegyeket, ami messze felülmúlta a többrétegű perceptronos megoldást. 
\newline
\indent
Dave Steinkraus, Patrice Simard és Ian Buck 2005-ben publikált dolgozata\cite{14} letette az alapjait a neuronhálók videokártyán történő programozásának. A videókártyán történő adatpárhuzamos programozás hatalmas performancia növekedést jelentett a processzoron futó neuronhálókkal szemben. Előtérbe kerül a deep learning és a mély konvolúciós hálók használata\cite{1}\cite{2}.
\newline
\indent
Eddigiekben sikerült nagyon pontos felismerő illetve osztályozó rendszereket alkotni. A mély konvolúciós hálók használata azonban nem merül ki ennyiben. 2015-ben publikálásra került egy olyan deep learning-et használó algoritmus, ami képes képek illetve festmények művészeti stílusát átvinni egy másik digitális képre\cite{15}. Mostani dolgozatom is erre a publikációra alapoz, az ebben bemutatott módszereket próbálja alkalmazni illetve továbbfejleszteni. A tanuláshoz egy korábban bevezetett és gépi látáshoz használt, előre betanított neuron hálót használnak fel, a VGG-19-et. Yaroslav Nikulin és Roman Novak tudományos kutatása\cite{16} ezzel szemben eddig ugyanezt a módszert alkalmazta más ismertebb előre betanított hálókra, mint például AlexNet, GoogLeNet vagy VGG-16. Ugyanúgy a VGG-16 háló használata is kiváló eredményeket mutatott míg a GoogLeNet és az AlexNet architektúrájuk miatt komolyabb információvesztéshez vezetnek így a végeredmény nem lesz annyira látványos. Ugyanúgy kísérletek irányultak az eredi eljárás optimalizálására, megjelentek olyan rendszerek amik sajátos, erre a célre betanított neuron hálókat alkalmaznak\cite{17}\cite{18}\cite{19}.
\newline
\indent
2016-ban a Prisma labs inc. kiadta mobilos applikációját Prisma név alatt\cite{20}. Az aplikáció előre megadott ismert festői/grafikai stílusokat alkalmazza a telefon kamerája által készített képekre. Az applikáció az előbbiekben bemutatott kutatásokra alapoz. Ugyanakkor fontos megjegyezni, hogy maga a stílus alkalmazását a különböző fotókra nem az okostelefon végzi. A szerkeszteni kívánt képet a telefon felkülde egy szervergépre ami majd válaszként a szerkesztett képet küldi vissza. 
\newline
\indent
Maga stílusátvitel nem csak állóképekre alkalmazható, ezt bizonyította Manuel R., Alexey D., Thomas B. tudományos dolgozata\cite{21}, valamit ezt próbalja megoldani a jelenlegi dolgozatom is. Értelemszerűen egy adott videót több álló képkocka alkot. Viszont ahhoz, hogy látványos művészeti mozgóképet gyártsunk, nem elegendő maga a videót darabokra vágni és minden képkockára alkalmazni a stílust. Erre adott megoldást Manuel R. és társainak kutatása. 


%-------------------------------------------------------------
\chapter{A rendszer}
\capterro{Sistemul}
\capteren{The system}

%-------------------------------------------------------------
\section{Áttekintés}
\secro{Privire de ansamblu asupra}
\secen{Overview}
Dolgozatom célja egy olyan multiplatform számítástechnikai szoftver tervezése és fejlesztése ami deep learning-et használva képes híres magyar festők festményeinek a stílusát átvenni és alkalmazni a felhasználó által megadott digitális képekre illetve videókra. A fejlesztett szoftver könnyen használható grafikus felhasználói felülettel rendelkezik és támogatja a Linux valamint a Microsoft Windows alapú operációs rendszereket. A szoftver futtatásához a felhasználónak rendelkeznie kell egy olyan videókártyával ami támogatja az Nvidia CUDA platformot. 
\newline
\indent
A szoftver fejlesztése Python3.5\cite{23} programozási nyelvben történt, viszont egyes esetekben felhasználásra kerülnek egyes előre legyártott önállóan is futtatható állományok. Emellett még használva vannak a következő Python könyvtárak:

\begin{itemize}
	\item numpy\cite{24}: használata elengedhetetlen akkor, ha többdimenziós tömbökkel szeretnénk dolgozni. Nagyon sok matematikai problémára tartalmaz előre definiált megoldást és efelett tökéletesen használható a tensorflow könyvtár mellett
	\item tensorflow\cite{7}: talán egyik legismertebb deep learning és mély konvolúciós hálók tanítására kifejlesztett könyvtár. Teljes mértékben támogatja a videókártyán történő programozást.
	\item PyQt\cite{25}: a szoftver grafikus felhasználói felületének a megvalósításához használatos, emellett komoly feladat orientált párhuzamosítást tud biztosítani.
	\item OpenCV\cite{26}: képfeldolgozásra szakosodott könyvtár, főleg a különböző kiterjesztésű képek beolvasására és mentésére volt használva.
\end{itemize}

A rendszer működése felülnézetből nagyon egyszerű (\ref{felulnezet_1} ábra). A felhasználó kiválaszt egy bemeneti állományt, ami kép kiterjesztésű (.jpg, .png) vagy mozgókép kiterjesztésű (.gif, .avi, .mp4) lehet valamint kiválaszt egy stílust a megadottak közül. A rendszer annak függvényében, hogy milyen bemenetet adtunk, eldönti, hogy kép vagy mozgóképpel kell dolgoznia. Kép esetén egyszerűen lefuttatja a tanulási algoritmust amely során az átveszi a művészeti kép stílusát. Mozgókép esetén képkockákra bontja azt, majd minden képkockára alkalmazva lesz a tanítási algoritmus. Ha összes képkocka szerkesztve lett, akkor a rendszer felépíti a képkockákból a kimeneti videót. Ezek után, függetlenül, hogy kép vagy videó lett a végeredmény, a rendszer kimenti azt egy megadott folderbe.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.5]{software_overview.png}
		\caption{A rendszer működése felülnézetből}
		\label{felulnezet_1}
	\end{center}
\end{figure}

\section{Párhuzamos gépi tanulás Tensorflow segítségével}
\secro{Învățare automată cu ajutorul librăriei Tensorflow}
\secen{Parallel machine learning using Tensorflow}

\subsection{A Tensorflow alap konceptusai}
\ssecro{Conceptele de bază a librăriei Tensorflow}
\ssecen{The basic concepts of Tensorflow library}

A Tensorflow egy gépi tanításra alkalmas könyvtár. Tensorflow segítségével leírt algoritmus nagyon kevés kódmodosítással számos eszközön futtatható, kezdve a mobil eszközöktől egészen a GPU-kal ellátott osztott rendszerekig. Főleg a deep learning típusú algoritmusok implementálására használatos, viszont flexibilitásából adódóan számos más tanítási folyamat elvégzésére is képes \cite{35}.
\newline
\indent
A Tensorflow működése leíraható egy irányított gráf segítségével. A gráf az adat áramlását reprezentálja, míg a gráfban levő csúcsok jelentik a kontrollt az adat áramlása fölött. Egy ilyen gráfban minden csúcsnak 0 vagy több bemenetele van, valamint 0 vagy több kimenettel rendelkezik. Minden csúcs egy operációt jelent. A csúcsok közt folyó adatothalmazokat tenzoroknak nevezzük. Valójában egy tenzor egy N dimenziós tömböt jelent. Speciális élek is létezhetnek a gráfban az adatfolyam kontrollálására. Ilyen él lehet például egy olyan ami megtiltja, hogy adat folyon át rajta \cite{35}.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.8]{tensorflow_graph.png}
		\caption{Tensorflow számítási gráf\cite{35}}
		\label{tensorflow_graph}
	\end{center}
\end{figure}

Az operációknak lehetnek nevük és attributumaik. A kernel egy operáció implementációja ami egy adott típusú hardveren (CPU vagy GPU) fut. Különféle típusú kerneleket különböztetünk meg, amik lehetnek alap matematikai műveletek (összeadás, kivonás, szorzás, osztás, logaritmus, kisebb, nagyobb, egyenlőség, stb.), tömb műveletek (konkatenálás, felvágás, rang, stb.), mátrix műveletek (mátrix szorzás, inverz, determináns, stb.), neuron háló réteg típusok (softmax, szigmoid, ReLu, konvolúciós, stb.), szinkronizációs műveletek (mutex műveletek, sorba állítás) és adatfolyam kontrollálásra szolgáló műveletek.
\newline
\indent
Ahhoz, hogy a számítási gráfban definiált műveleteket elvégezhessük, szessziókat (session) kell definiálni. Szessziók használata megengedi a teljes gráf kiértékelését vagy akár részleges kiértékelést is. A gráf kiértékelése a szesszió Run függvényével történik. 
\newline
\indent
A váltózó egy olyan tenzot ami megtartja az értékét többszörös számítási gráf kiértékelés esetén is. A változó egy olyan tenzorra utal aminek tartalma megváltozhat, ezzel ellentétben létezik a konstans aminek tartalma nem változhat.
\newline
\indent
A Tensorflow párhuzamosításra úgynevezett processzeket használ (\ref{single_proc_vs_multiple_proc}. ábra). A kliens szoftver egy szesszió interfészen keresztül kommunikál a master processzel és a worker proceszekkel. Mindenik procesz felelős egy vagy több számítási eszközért (computation device), amik lehetnek CPU magok vagy GPU kártyák. Ezek az eszközök lehetnek lokálisak, ami azt jelenti, hogy ugyanabban a rendszerben helyezkednek el, vagy lehetnek osztottak, ez esetben külön rendszerekben helyezkednek el a különféle eszközök. Minden eszköz saját névvel rendelkezik\cite{35}.

\subsection{Futtatás egyetlen készülék esetében}
\ssecro{Execuție pe un simplu device}
\ssecen{Execution in case of a single device}
Egyetlen eszköz jelenlétében a csúcsok egymást követően lesznek kiértékelve figyelembe véve a közöttük levő dependenciákat. Minden csúcs esetében számolva van, hogy hány dependenciát tartalmaz, ha ezek közül egyik ki volt értékelve, akkor ez a számláló csökken. Mikor a számláló elérta a 0-át, akkor továbblép és kiértékeli e következő csúcsot. A kiértékelésre várakozó csúcsok egy listába vannak elhelyezve.

\subsection{Futtatás több készülék esetében}
\ssecro{Execuție pe mai multe device-uri}
\ssecen{Execution in case of multiple devices}
Több készülék esetében szükséges eldönteni, hogy az adott csúcsok melyik készüléken fognak kiértékelődni, valamint fontos megoldani a készülékek közötti kommunikációt.
\newline
\indent
A csúcsok elhelyezése egy mohó esztimációs módszert követ. Minden csúcs esetében megesztimálható, hogy a bemeneti és kimeneti tenzorok mérete byte-ban. Ugyanakkor megesztimálható a futási idő adott csúcsok esetében. Ezután egy szimuláció fog lefutni ami az összes csúcs esetében kilistázza a használható eszközöket majd kiértékeli a futási időt valamit a kommunikáció idejét az eddigi elhelyezett csúcsokkal. A mohó algoritmus szerint arra az eszközre fog kerülni, ami a szimuláció során a legjobb eredményt adta.
\newline
\indent
Az eszközök közötti kommunikációt Send-Receive csúcsok beiktatásával oldja meg. Ezek a csúcsok ugyanakkor megoldják az eszközök közötti szinkronizációt is. Osztott rendszerek esetében ugyancsak Send-Receive csúcsok oldják meg a kommunikációt. Ezek TCP és RDMA protokollokat használnak az adat mozgatásához\cite{35}.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.6]{single_proc_vs_multiple_proc.png}
		\caption{Egyetlen procesz összehasonlítása több proceszes működéssel\cite{35}}
		\label{single_proc_vs_multiple_proc}
	\end{center}
\end{figure}

\subsection{Párhuzamos tanítás}
\ssecro{Antrenare paralelă}
\ssecen{Parallel trainig}

A Tensorflow könyvtár az adatpárhuzamosítást megközelíti úgy adatpárhuzamosítás szempontjából, mint feladat párhuzamosítás szempontjából. Adatpárhuzamosítás esetében az adatot kisebb csomagokba bontja, majd ezeket párhuzamosan bemenetként táplálja a megfelelő csomópontonknak. A kiértékelendő csomópontokból egy másolat kerül az összes szálra (\ref{data_parallel_tf_model}. ábra). A végeredményt egy redukciós művelet gyűjti össze.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.5]{data_parallel_tf_model.png}
		\caption{Adatpárhuzamos szinkron és aszinkron csomópont kiértékelés\cite{35}}
		\label{data_parallel_tf_model}
	\end{center}
\end{figure}

Feladatpárhuzamosítás esetében külömböző gráfrészletek lesznek megtanítva ugyanabban az időben különböző szálakon. Mikor a tanítás befejeződik, akkor az a procesz egy újabb gráfrészlet kiértékelésének fog neki. Ilyenfajta tanítás esetében fontos figyelembe venni azt, hogy egyes gráfrészletek csak akkor értékelhetőek ki, ha már előttük egy másik gráfrészlet le volt futtatva. Feladatpárhuzamos tanítást a \ref{data_parallel_tf_model}. ábra szemlélteti.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.8]{task_parallel_tf_model.png}
		\caption{Feladatpárhuzamos tanítás\cite{35}}
		\label{task_parallel_tf_model}
	\end{center}
\end{figure}


\section{A tanítási módszer állóképek esetében}
\secro{A tanítási módszer állóképek esetében}
\secen{A tanítási módszer állóképek esetében}

A rendszer tanításához állokép esetében két legalább képet bemenet szükséges, az eredeti kép, amire át szeretnénk ruházni a stílust és a stílust tartalmazó kép, aminek a stílusát át szeretnénk ruházni. Mindkét bemenet esetében felírunk egy veszteség függvényt amik részei a végső nagy tanítási függvénynek.

\subsection{Az eredeti kép tanításának a veszteségi függvénye}
\ssecro{Az eredeti kép tanításának a veszteségi függvénye}
\ssecen{The loss function of the content image}

A mély neurálos hálók (Deep Neural Networks) azon típusai amik a legeredményesebbek a képfeldolgozási feladatok elvégzésben a konvolúciós hálók. Mesterséges intelligencia területén a konvolúciós hálók olyan feed-forward típusú neuronhálók, amiket a biológiai elsődleges látókéregről mintáztak. A háló kifejezetten arra volt tervezve és kifejlesztve, hogy kétdimenziós formákat ismerjen fel. A háló alapértelmezetten több rétegből tevődik össze:

\begin{itemize}
	\item konvolúciós réteg: a konvolúciós hálók alap kövei. A réteg súlyai úgynevezett konvolúciós szűrők alkotják, amelyek a forward pass lépés során tanítva vannak. Ez a tanítási lépés úgy történik, hogy a szűrőt végig toljuk a bemeneten és konvolúciónak nevezett műveletet végzünk. 
	\item pooling layer: arra használatos, hogy a bemeneti adathalmazt méretét leszűkítsük úgy, hogy a halmaz adott értékein valamely matematikai műveletet végzünk (átlagszámolás, maximum számolás, minimum számolás). Erre azért van szükségünk, hogy növeljük a tanulás gyorsaságát, csökkentsük a számítások komplexitását megakadályozva ezzel az "overfitting" bekövetkezését.
	\item fully connected layer: minden bemenet mindem más bemenettel kapcsolatban áll.
\end{itemize}

A konvolúciós hálók súlyzókként konvolúciós szűrőket tartalmaznak. Ezek, tárgyfelisrmerés tanítása esetében, az adott bemeneti kép különböző tulajdonságait fogják tartalmazni. Annak függvényében, hogy a háló topológiájában egy adott réteg hol helyezkedik el, más tulajdonságokat fognak raktározni a szűrök. Az bemeneti réteghez közel álló alacsony szintű rétegek az adott kép pixelinformációit próbálják megjegyezni ezzel szemben a magasabb szinten levő rétegek szűrői különböző tárgyakat, formákat próbálnak megjegyezni\cite{27}\cite{28}. A hálók által tartalmazott információ vizualizálható azáltal, hogy rekonstruáljuk a bemeneti képet a súlyzók alapján. Alacsony rétegek esetében apró módosításokkal visszanyerhető az eredeti kép míg magasabb rétegek esetében objektumok, formák nyerhetők vissza.

Az eredi kép tanításához egy már előre betanított mély konvolúciós neuronhálót használunk fel. A háló tudományos kontextusban VGG-19 név alatt terjedt el amit Simonyan K. és  Zisserman A. vezetett be publikációjukban\cite{29} ahol még a "model E" nevet viselte. Ez a háló gép látás és tárgyfelismerés céljából volt bevezetve olyan eredményeket produkálva e téren amik az emberi látással versengenek. Rétegei és topológiájának részletes bemutatása a \cite{29} publikációban történik, valamint a \ref{vgg_19} figurán is látható. Fontos megjegyezni, hogy a háló rétegeiből használva volt a 16 konvolúciós réteg, valamint az 5 pooling réteg, a teljesen összekötött rétegek nem voltak használva.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.7]{VGG19.png}
		\caption{VGG-19 (Model E) háló topológiája\cite{29}}
		\label{vgg_19}
	\end{center}
\end{figure}

A választás azért esett erre az előre betanított hálóra, mivel Yaroslav N. és Roman N. kutatása alapján\cite{16} összehasonlítva a AlexNet, GoogLeNet VGG-16 és VGG-19 halókat, a VGG-19 használata során sikerült a leglátványosabb képeket készíteni.
\newline
\indent
A konvolúciós neuron háló minden rétege tartalmaz egy adott számú szűrőt, amik különbőző tulajdonságokat tartalmaznak a bementi képről. Ebből kifolyólag maga a bemenet kódolva van a szűrőkben. Egy \(N\) tulajdonságót tartalmazó réteg \(N\) szűrővel rendelkezik amelyek mérete \(M\). Maga a réteg kimenete lementhető egy \(N * M\) -es mátrixban. Egy adott réteg válasza egy bemeneti képre vizualizálható, ha gradient descent módszert alkalmazunk egy fehér zajt tartalmazó bemeneti képen. Tehát, legyen \(R^l\) egy adott az \(l\) haló válasza egy adott bemeneti képre. Legyen \(W^l\) ugyanaz az \(l\) háló válasza egy adott fehér zajt tartalmazó bemeneti kép esetében. Akkor felírható a veszteség függvény mint:

\begin{equation}
L_{content}(\vec{x}, \vec{r}, l) = \frac{1}{2}\sum{R^l_{ij} - W^l_{ij}}
\end{equation}

Ahol \(\vec{x}\) a bemeneti képet jeleni, \(\vec{r}\) pedig azt a kimeneti képet jelenti amit a rendszer generál a rétegek tulajdonságaiból.
Mindez Tensorflow környezetben a következőképpen nézne ki:

\begin{lstlisting}[language=Python]
for layer_name in CONTENT_LAYER:
	content_loss += content_weight * (2 * tf.nn.l2_loss(
		all_layers[layer_name] - content_features[layer_name]) /
		content_features[layer_name].size)

content_loss /= len(CONTENT_LAYER)
return content_loss

\end{lstlisting}

A \(CONTENT\_LAYER\) tuple típusú ami tartalmazza azoknak a rétegeknek az azonosítóját amik részt vesznek a veszteség függvény kiszámításában. A \(content\_features\) valtozó egy lista, ez tartalmazza az összes réteg válaszát a bemeneti eredeti képre. A visszaküldött érték egy tensor típusú, egyik részét fogja képezni a végső optimalizálandó veszteségfüggvénynek. 


\subsection{Az stílus kép tanításának a veszteségi függvénye}
\ssecro{Az stílus kép tanításának a veszteségi függvénye}
\ssecen{The loss function of the style image}
Az előbbiekben az eredeti bemeneti kép tartalmára voltunk kíváncsiak. A stílus kép esetében viszont nem maga a kép tartalma a fontos. Ebben az esetben egy mintázatot szeretnénk kinyerni a stílusképből. Ehhez fontos megismerni maga a Gramm mátrix fogalmát. Hogyha adott egy vektorhalmazunk \(v1...vn\), akkor a \(G\) Gramm mátrixot a következő eljárás szerint határozzuk meg\cite{30}:

\begin{equation}
G_{ij} = v_i \cdot v_j
\end{equation}

Tehát hogyha az \(A\) mátrixunk oszlopait maga a \(v1, v2 ... vn\) vektorok képezik, akkor a \(G\) Gramm mátrix a következőképpen kapható meg:

\begin{equation}
G_{ij} = A A^T
\end{equation}

A Gramm mátrix egy szorzatot jelen egy adott vektorhalmaz összes elemei között. A mi esetünkben ez a vektorhalmaz jelentheti egy adott konvolúciós réteg által kiszűrt tulajdonságokat az adott bemeneti stílusképből. Amint már említettem, maga a konvolúciós réteg szűrői egy adott kép tulajdonságait tartalmazzák. A Gramm mátrix \(ij\) pozíciójában elhelyezkedő elem megadja, hogy egy adott réteg \(i\)-dik tulajdonsága mennyire teljesül a \(j\)-dik tulajdonság jelenlétében, tehát a két tulajdonság milyen mértékben aktiválódik egyszerre. Ha az \(ij\) pozícion levő elem közelít a \(0\)-hoz, akkor az azt jelenti, hogy a két tulajdonság nem aktiválódik egyszerre, ezzel ellentétben, ha az érték nagy, akkor az azt jelenti, hogy a két tulajdonság nagy valószínűséggel aktiválódik egyszerre.
\newline
\indent
Hogyha az \(l\) rétegnek \(N\) szűrője van, akkor \(G \in R^{N_l*N_l}\), ahol:

\begin{equation}
G^l_{ij} = \sum_{k} F^l_{ik} \cdot F^l_{jk}
\end{equation}

Ahhoz, hogy megkapjuk egy adott háló által generált mintát, textúrát, hasonlóan mint az előzőekben, fehér zaj képet adunk bemenetként. A veszteségfüggvény egyetlen hálóra felírható mint a fehér zaj képre adott válasz és a stílus képre adott válasz átlagos négyzetes hibájaként. A \(G\) jelenti a fehér zaj képre adott választ, az \(A\) pedig a stílus képre adott választ.

\begin{equation}
E_l = \frac{1}{4N^2_l M^2_l} \sum_{i,j} (G_{ij} - A_{lj})^2
\end{equation}

Az összes stílus réteg válasza felírható, mint egy összeg, ahol \(w_l\) egy súlyzó faktort jelent:

\begin{equation}
L_{style}(\vec{a}, \vec{x}) = \sum w_lE_l
\end{equation}

\subsection{A stilizált kép tisztítása}
\ssecro{Reducerea zgomotului din imagenea stilizata}
\ssecen{Denoising the stylized image}
A két veszteségfüggvényt alkalmazva sikeresen át tudjuk ruházni a stílust a művészi képről a bemeneti mindennapi képre. Viszont észlelhetjük, hogy az eredmény kép eléggé zajos. Ennek érdekében bevezetünk egy újabb veszteségfüggvényt a zaj csökkentésére, ami a Total Variation Denoising algoritmusra alapszik. Az algoritmus szerint vesszük a stilizált képet és eltoljuk X koordináta mentén egy pixellel, majd az Y koordináta mentén is eltoljuk egy pixellel. Az eltolt képeket kivonjuk az eredi képekből, majd az eredmények abszolút értékeit pixelenként összeadjuk. Ezáltal egy újabb veszteségi függvényt alítunk elő, amit ugyancsak minimalizálni kell.

\begin{equation}
L_{tv}(\vec{a}, \vec{x}) = \sum_{i,j} \left|(X_{ij} - A_{{i+1}j})\right| + \sum_{i, j} \left|(X_{ij} - A_{i {j+1}})\right|
\end{equation}

\subsection{A teljes veszteségfüggvény felírása és tanítása statikus képek esetében}
\ssecro{Definirea si învățarea funcției de pierdere totala la imagini statice}
\ssecen{The definition and optimization of the total loss function for static images}

Eddig bemutatásra került a stílus kép tanításának veszteségfüggvénye, az eredeti kép veszteség függvényének tanítása valamint egy veszteségfüggvény a kimeneti kép zajtalanítására. A végső veszteségfüggvény egyszerűen felírható a három veszteségfüggvény összegeként. 

\begin{equation}
L = L_{content} + L_{style} + L_{tv}
\end{equation}

A teljes veszteségfüggvény tanítására az Adam\cite{32} optimalizáló algoritmus alkalmaztuk. Az Adam ( Adaptive Moment Estimation) momentum algoritmus egy sztochasztikus gradiens alapú optimalizáló algoritmus. Az algoritmus felhasználja a elsődleges, valamint a másodlagos gradiensek átlagát ahhoz, hogy a veszteségfüggvényt minimalizálja. Az optimalizálási lépések a következő eljárás szerint történnek:

\begin{equation}
\begin{aligned}
(m_t)_i=\beta_1(m_{t-1})_i + (1 - \beta_1)(\nabla L(W_t))_i \\
(v_t)_i=\beta_2(m_{t-1})_i + (1 - \beta_2)(\nabla L(W_t))^2_i \\
\\
(W_{t+1})_i = (W_t)_i - \alpha \frac{\sqrt{1-(\beta_2)^t_i}}{1-(\beta_1)^t_i} \frac{(m_t)_i}{\sqrt{(v_t)_i} + \varepsilon} \\ 
\cite{33}
\end{aligned}
\end{equation}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.9]{total_loss_values.png}
		\caption{Tanítási függvény optimalizálása különböző tanítási ráták esetében}
		\label{total_loss}
	\end{center}
\end{figure}

Ahol, \(m\) és \(v\) jelentik az elsőfokú valamint másodfokú gradienseket, \(W\) jelenti a súlyzókat, \(\beta_1\) és \(\beta_2\) jelentik a momentumokat, emellet \(\varepsilon\) egy nagyon kis értékű szám annak érdekében, hogy elkerüljük a 0-val való osztást.
\newline
\indent
Értelemszerűen a tensorflow deep learning könyvtár beépítetten tartalmazza a Adam optimalizációs algoritmust, ezért ennek a leprogramozására nincs szükség. 

\section{A tanítási módszer mozgóképek esetében}
\secro{A tanítási módszer mozgóképek esetében}
\secen{A tanítási módszer mozgóképek esetében}

\subsection{Naiv megközelítés}
\ssecro{Naiv megközelítés}
\ssecen{Naiv approach}

Eddigiekben bemutatásra keszült miképpen vihető át a stílus egyik statikus képről a másikra. Mindenki tisztába van azzal, hogy egy videó statikus képek sorozatából tevődik össze, amiket képkockáknak (frame) nevezünk. Ennek megfelelően a naiv megközelítés az lenne, hogy ha adott egy videó, akkor vágjuk azt darabokra, pontosabban statikus képkockákra, majd az összes képkockára alkalmazzuk a stílus átruházási módszert.
\newline
\indent
A bemeneti videót frame-ekre való bontásához az ffmpeg nyílt forráskodú alkalmazást használtuk. Az ffmpeg parancssorból futtatható, a következő paraméterek szükségesek, ahhoz, hogy a mozgóképet statikus képek sorozatává alakítsa:

\begin{lstlisting}[language=bash]
ffmpeg -i <input_video_path> -f image2 frame%05d.<ext>
\end{lstlisting}

A \(frame\%05d.<ext>\) egy mintát jelent ami szerint a képkockák elnevezését határozza meg. Az \(<ext>\) a képkockák kiterjesztését jelenti.
\newline
\indent
Miután a stílus átruházása az összes képkockára megtörtént, vesszük az összes stilizált képkockát és felépítjük belölük a kimeneti videót. Ez ugyancsak megoldható az ffmpeg alkalmazással.

\begin{lstlisting}[language=bash]
ffmpeg "-i" frame%05d.<ext> output_name.<ext>
\end{lstlisting}

A naiv megközelítés működik, a kimenet egy olyan videó lesz, amely tartalmazza a bemeneti stíluskép jellegzetességeit. Ugyanakkor észlelhető, hogy az eredmény nem valami esztétikus. Észlelhető, hogy a képkockák közötti átmenet nem valami folyamatos. Emellett különböző zajokat, úgynevezett artifact-eket észlelhetünk. 

\subsection{A haló inicializálása képkockák esetében}
\ssecro{A haló inicializálása képkockák esetébe}
\ssecen{A haló inicializálása képkockák esetébe}
Amint említettük, a háló inicalizálására egy fehér zaj képet használtunk statikus bemeneti képre való stílusátruházáskor. Több képkocka esetében ezzel az a gond, hogy a képkockák nem fognak egyanabba a lokális minimumba konvergálni tanításkor. Végeredményképp az átmenet egyik képkockáról a másikra nem lesz folyamatos.
\newline
\indent
Egy megoldás kísérlet erre az lenne, hogy a ha egy képkocka stilizálása történik, a hálót ne fehér zaj képpel inicializáljuk, hanem az előtte levő stilizált képkockával. Ez simább átmenetet fog eredményezni abban az esetben, ha a képkockákon nincs mozgás. Ennek a módszernek a használata szükségszerű viszont nem elégséges ahhoz, hogy szemnek is kellemes eredményt kapjunk.

\subsection{Optical flow bevezetése}
\ssecro{Introducerea optical flow-ului}
\ssecen{Introduction of the optical flow}

Az optical flow egy mozgóképen megjelenő objektum különböző sebességvektorait jelenti. A képt képkocka közötti optical flow megesztimálásával mérhető az adott objektum valós mozgási sebessége. A kamerához távolabb levő objektumok kisebb sebességvektorokkal rendelkeznek mint azon objektumok amelyek ugyanazon sebességgel mozognak, viszont közelebb vannak a kamerához\cite{34}.
Az optical flow meghatározásához a DeepMatching - Deepflow algoritmust használtuk. Ennek a kimenete egy .flo kiterjesztésű fájl ami tartalmazza adott pixelek esetében a horizontális és vertikális elmozdulás vektorokat.
\newline
\indent
Az optical flow meghatározásával egy mozgóképen meghatározhatók azok a régiók, amik statikusak (adott időn belül az illető régióban nincs változás, úgymond nincs mozgás) valamint azokat a régiókat ahol változás történik. Ami még fontos nekünk meghatározni egy adott mozgó objektum/személy esetében azt az kétdimenziós intervallumot, amelyben mozog. Meghatórozzuk a mozgási határait (lásd: ). Ennek a metódusát Sundaran és társai írják le a ... publikációjukban.
\newline
\indent
Két egymést követő képkocka esetében meghatározható az optical flow előre, tehát az képkockák időrendi sorrendjében, valamint meghatározható visszafele, az időrendi sorrend ellentett irányában. Jelölje \(w(i, j)\) az előre történő optical flow-t, valamint \(\hat{w}(i, j)\) a visszafele történő optical flow-t. Ekkor felírható a w torzítása a w alapján:

\begin{equation}
\tilde{w}(i, j) = w((i, j) + \hat{w}(i, j))
\end{equation}

A mozgás néküli zónák meghatározhatóak a következőképpen:
\begin{equation} \label{eq:1}
|\tilde{w} + \hat{w}|^2 > 0.01(|\tilde{w}|^2 + |\hat{w}|^2) + 0.5
\end{equation}

A mozgási határok pedig meghatározhatóak:
\begin{equation} \label{eq:2}
|\nabla\hat{u}| + |\nabla\hat{v}| > 0.01|\tilde{w}|^2 + 0.002
\end{equation}

A \ref{eq:1} és \ref{eq:2} képletek alapján alkotható egy olyan mátrix ami tartalmazza a mozgás néküli zonánkat valamint a mozgási határokat. Ezt a mátrixot átalakítjuk olyan módon, hogy a mozgási határokra 1-est rakunk, a többi érték 0-ás lesz, jelöljük ez a mátixot \(c^{(i-1,i)}\)-vel az \(i-1\) és \(i\)-dik képkocka között. Ezt felhasználva felírhatjuk egy újabb veszteség függvényt: 

\begin{equation} \label{eq:2}
L_{temporal}(x, w, c) = \frac{1}{D}\sum_{k=1}^{D}c_k\cdot(x_k-w_k)^2
\end{equation}


\section{A rendszer tervezése és kivitelezése}
\secro{Proiectarea și implementarea sistemului}
\secen{The design and implementation of the system}

\subsection{A rendszer interakciós és viselkedési modellje}
\ssecro{Modelul de interacțiune și comportament al sistemului}
\ssecen{Interraction and behavioral model of the system}

A rendszer interakciós modellje (\ref{use_case_diagram}. ábra) a lehető legegyszerűbb. Egyetlen aktort határozunk meg, aki maga a felhasználó. A rendszer esetében nem beszélhetünk bármilyen adminisztrációs felületről mivel nem rendelkezik semmiféle háttértárral valamint nem pillanatnyilag nem definiál semmifel hálózati komponenst.
\newline
\indent
A felhasználónak lehetősége van új kép illetve videó anyag bevitelére. Ez a funkcionalitást egyazon komponens végzi aminek a egyik feladata eldönteni, hogy a kijelölt bemenet kép vagy videó típusú. A felhasználónak lehetősége van a meghatározott kiterjesztésű fájlok közül választani bemenethez.
\newline
\indent
A felhasználónak lehetősége van a rendszer által biztósított stílusok közül választani. A felhasználó nem határozhat meg új stílust. A rendszer nem biztosít erre adminisztrációs felületet.
\newline
\indent
A felhasználó meghatározhatja az átruházási folyamat tanítási paramétereit. A rendszer erre biztosít alapértelmezett értékeket amiket a felhasználó változtathat. A rendszer megjegyzi az új paramétereket, ezek új indításkor is megmaradnak. A rendszer az alapértelmezett paramétereket is megjegyzi, ezeket a felhasználó bármikor visszálíthatja az erre kifejlesztett opció használatával.
\newline
\indent
A felhasználó meghatározhatja az utvonalat ahova a kimenet le lesz mentve. A mentést a rendszer automatikusan el fogja végezni az átruházási folyamat után.

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.55]{use_case.png}
		\caption{A rendszer viselkedési modellje}
		\label{use_case_diagram}
	\end{center}
\end{figure}

A rendszer interakciós modelljét az \ref{felulnezet_1}. ábra tartalmazza. A felhasználó kiválaszt egy bemeneti állományt a rendszer által meghatározott kiterjesztések közül(.jpg, .png, .gif, .avi, .mp4), majd kiválaszt egy stílust a megadottak közül. A rendszer annak függvényében, hogy milyen bemenetet adtunk, eldönti, hogy kép vagy mozgóképpel kell dolgoznia. Kép esetén lefuttatja a 3.2-es fejezetben ismertetett taítási algoritmust amely során az átruházza a művészeti kép stílusát. Mozgókép esetén képkockákra bontja azt, majd alkalmazva lesz a 3.3-as fejezet tanítási metódusa. Ha összes képkocka szerkesztve lett, akkor a rendszer felépíti a képkockákból a kimeneti videót. Végezetül a rendszer lementi a megadott helyre a kimeneti állományt.

\subsection{A rendszer strukturális modellje}
\ssecro{Modelul structural al sistemului}
\ssecen{Structural model of the system}

A rendszer a következő komponensekből tevődik össze (\ref{component_diagram}. ábra):
\begin{itemize}
	\item Main Window: az aplikáció fő ablaka, ez az ablak jelenik meg az applikáció indításakor, valamint erről az ablakról lehet kiválasztani a bemeneti adatot és a stílus képet. Az ablak Start gombjának a lenyomásával indítható az átruházási folyamat. Az ablak tartalmaz két beágyazott területet, ahol a bemeneti adat, valamint a végeredmény tekinthető meg.
	\item Settings Dialog: a főablak menüsorából (Menu Bar) jeleníthető meg. Fő feladata egy grafikus felület biztosítása a különféle beállítások és tanítási paraméterek megadásához. A felhasználó megadhatja az útvonalat ahhoz a mappához, ahova a kimenet lesz tárolva, megadhatja a bemeneti VGG19 háló útvonalat valamint a tanítási paramétereket.
	\item ProgressBar Dialog: a feladata kimutatni a felhasználó számára, hogy az átruházás milyen státusban van, mennyi van még hátra amig a folyamat befejeződik. Erre azért van szükség, mivel az átruházási folyamat időigényes, ezért fontos a felhasználó tudtára adni, hogy milyen állapotban van a folyamat. A folyamat befejeztekor egy jelzést küld a Main Window komponensnek, ami ki fogja jelezni a felhasználónak a végeredményt.
	\item Artistic Video creator: ez képezi az aplikáció magját, ez az a komponens, ami elvégzi maga az átruházási folyamatot. A bemeneti paramétereket/adatokat a Main Window komponenstől kapja. Az átruházási folyamat a videó kártyán fog futni, de ettől föggetlenül a komponens jelzéseket fog küldeni a ProgressBar komponensnek.
	\item Image handler: feladata a bemeneti képek beolvasása és kiíratása a merevlemezre. Beolvasáskor egy preprocesszálás műveletet végez, majd kimenetkor egy poszprocesszálás művelet lesz elvégezve. Fontos megjegyezni, hogy ezt a komponens a processzálások miatt nem ajánlott használni applikáción belüli képkijelzésre, például a Main Window komponens esetében.  
	\item Video handler: feladata a bemeneti videot képkockákra vágni és a kimeneti képkockákból videót készíteni. A képkockák egy temporális folderbe lesznek elmentve vágás után, ezeknek a beolvasását a Image handler komponens végzi majd.
	\item VGG19 handler: a komponens feladata ez előre betanított és kimentett VGG19 háló beolvasása és átalakítása egy olyan hálóvá amit a Tensorflow könyvtár fel tud dolgozni majd.
\end{itemize}

\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.5]{component_diagram.png}
		\caption{A rendszert alkotó komponensek}
		\label{component_diagram}
	\end{center}
\end{figure}

\subsection{Többszálas megoldás és kommunikáció a komponensek között}
\ssecro{Proiectarea pe mai multe fire computaționale a unelor componente}
\ssecen{Multithreaded design and communication of components}

A egy bemeneti képre való stílus átruházás időigényes folyamat. Mozgókép esetében ez a folyamat időigénye lineárisan növekedik a képkockák számának szorzatával. Annak érdekében, hogy az alkalmazásunk reszponzív legyen elhagyhatatlan aspektus egy olyan modell kialakítása ami igénybe veszi a modern processzorok többszálas működési tulajdonságát. Az Artistic video creator komponens működése során ugyan igénybe veszi a videó kártya számítási kapacítását, de ez semmiképp sem jelenti azt, hogy a futási idő elhanyagolható. Ugyanakkor fontos kiemelni azt is, azon függvényhívások sorozata ami a videókártyán fog elvégződni, szinkron módon történik. Valójában a programunk meghívja az adott függvényt majd addig várakozik, amig megoldás nem érkezett erre.
\newline
\indent
Alkalmazásunk esetében megkülönböztetünk egy főszálat valamint egy mellékszálat (\ref{seq_diagram}. ábra). A főszálon fog futni a Main Window és a köréje csoportosulú felhasználói felülettel rendelkező komponensek, mint például a Settings vagy a ProgressBar. Az alkalmazás indításakor csak a főszál indul el ami létrehozza a Main Window és Settings komponenseket. Ezt követően, ha a felhasználó megadja a bemeneti állományt, létrejön a ProgressBar komponens. A ProgressBar azért jön létre csak ebben a pillanatban, mivel a rendszernek el kell döntenie a bemenet típusát és ennek függvényében egy factory modell segítségével dönti el, hogy milyen típusú komponens jön létre. Ebben a pillanatban azonban a Progressbar komponens még nem látható a felhasználó számára.
\newline
\indent
Ha felhasználó úgy dönt, hogy a megfelelő bemenetet választotta ki, elindíthatja az átruházási folyamatot. Ekkor egy külön szál jön létre (Worker thread), ami átveszi a bemeneti adatokat és elkezdi a folyamatot. A terhelés ebben a pillanatban átkerül a másodlagos szálra, ennek eredményeképp a főszál nem fog blokkolódni. Így az felhasználói felület aktív marad a felhasználó számára és ki fogja tudni szolgálni annak kéréseit.
A munkafolyamat közben az Artistic Video creator komponens kapcsolatban áll a ProgressBar komponenssel és jelzéseket küld a munkafolyamat státusáról így ez ki tudja jelezni, hogy mennyi munka van még hátra. A munkafolyamat bármikor leállítható még azelőtt, hogy az átruházás befejeződött volna. Ilyenkor a ProgressBar üzenetet küld az Artistic Video creator komponensnek, ami beállít egy saját leállításra szánt flag-et. A folyamat két iteráció között állítható le, ha az illető flag be volt állítva. Miután a munkafolyamat sikeresen leállt, egy jelzés fog érkezni a ProgressBar komponenshez ami majd nyugtázni fogja. Ha a munkafolyamat bevégződőtt, vagy a felhasználó által megszakításra került, a másodlagos szál el fog halni, az ezáltal igényelt erőforrások pedig fel fognak szabadulni.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.5]{seq_diagram.png}
		\caption{Átruházás szekvencia diagrammja}
		\label{seq_diagram}
	\end{center}
\end{figure}

\subsection{A rendszer implementálása}
\ssecro{Impementarea sistemului}
\ssecen{The implementation of the system}

A rendszer implementációja Python környezetben történt. Ahogy már a bevezetőben is említésre került, aaz alábba könyvtárak kerültek felhasználásra: numpy, Tensorflow, opencv, PyQt. Az elkövetkezőkben ki szeretnék térni a PyQt könyvtár bemutatására ugyanis a szoftver jelentős része ennek a felhasználásával valósult meg és az implementációban használt egyes tervezési minták a PyQt sajátosságait próbálják kiaknázni.
\newline
\indent
A PyQt a híres Qt könyvtárra épül. A Qt egy C++ könyvtár aminek célja olyan grafikus szoftverek megvalósítása amik különböző platformokat is támogatnak. A Qt univerzális megoldást ad a grafikus felületek elkészítésére, de emellett számos más komponenseket is impementál, mint például tömbök, listák, konténerek, párhuzamos szálak, smartpointerek, hálozati protokollok, stb. A Qt egyik újítása a SIGNAL-ok és a SLOT-ok bevezetése. Ennek működése egyszerű, egy adott osztály adattagjai és metódusai mellett deklarálhatóak SIGNAL-ok és SLOT-ok is. Egy osztály egyes metódusai jelzésket adhatnak ki SIGNAL-ok segítségével amire a SLOT metódusok csatlakozhatnak. Egy adott SIGNAL kibocsátásakor a rá csatkakozott összes SLOT függvény le fog futni. Például egy grafikus felületen levő gomb lenyomásakor kibocsájtunk egy SIGNAL-t amire a neki megfelelő SLOT függvény meghívódik és lefut. A jelzéskibocsájtás működik többszálas program esetében is, az is megoldható, hogy egy adott jelzésre egy más szálon futó metódus válaszoljon. Természetesen a SIGNAL-SLOT megoldás a PyQt esetében is tökéletesen működik és egy nagyon kényelmes megoldást biztosít a grafikus felület és a business logika összekötésében.
\newline
\indent
A PyQt egy másik előnye az, hogy elegánsan megoldható a modell-nézet-kontroller szoftverfejlesztési minta. Maga a nézet megvalósítható XML leíró nyelv segítségével. Ebből autmatikusan generálható egy Python osztály, ami fel fogja építeni maga a kinézetet. Ezt a kontrollerbe be lehet integrálni kompozicióval majd a SIGNAL-SLOT-ok összekötése után használni lehet azt. 
\newline
\indent
A továbbiakban részletes bemutatásra és elemzésre kerül az aplikációnk objektum orientált megvalósítása (\ref{class_diagram}. ábra).

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.45]{class_diagram.png}
		\caption{A rendszer osztálydiagrammja}
		\label{class_diagram}
	\end{center}
\end{figure}

\subsubsection{A főablak (Main Window) komponens implementálásának bemutatása}
\sssecro{Implementarea componentei Main Window}
\sssecen{The implementation of the Main Window component}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.7]{mainwindow_component.png}
		\caption{MainWindow}
		\label{mainwindow_class}
	\end{center}
\end{figure}

A MainWindow komponens magába foglalja a fő felhasználói implementációját meg pár ehhez szorosan kapcsolódó segítő segítő osztályt(\ref{mainwindow_class}. ábra). Maga a fő ablak megvalósítását két részre bontottuk: maga a nézettel foglalkozó osztály(Ui\_MainWindow) és maga a back-end logikával foglalkozó osztályra (MainWindow). Az Ui\_MainWindow egyetlen feladata maga felhasználói felület nézetének definiálása, ezért ezt kompozicióval integrálujk a MainWindow osztályba. A felület (lásd: \ref{graphical_ui)}. ábra) rendelkezik két grafikus kép kijelzésére szánt ablakkal, amik QGraphicsScene típusúak. Ezek közül a bal ablakba fog megjelenni a bemeneti kép amit a felhasználó megad. A QGraphicsScene sajnos nem képes videóanyag beágyazására, ezért az alkalmazás egy előre megadott képet fog ilyenkor kijelezni a felhasználónak. 
\newline
\indent
A bemenet magadása a "Browse..." nyomógomb lenyomásával történik, ami jelzést fog küldeni a \_browse\_button\_clicked metódusnak. Ez létre fog hozni QFileDialog típusú beépített fájlböngésző ablakot. Ez fel van konfigurálva olyan módon, hogy csak az előre kijelölt típusú fájlkiterjesztéseket lehessen beolvasni ("Images/Videos (*.png *.jpg *.gif *.mp4)"). Ha fájlkiválasztás megtörtént, akkor a fájlnak az utvonala megjelenik a "Browse..." nyomógomb melletti szövegdobozban.
\newline
\indent
A MainWindow belső osztályként tartalmazza a SelectableGraphicsView osztályt. Ennek célja a stílusképek közötti váltogatás megoldása(\ref{mainwindow_class}. ábra). Az alkalmazás összes előredefiniált stílusképe látható a \ref{styles}. ábrán. Alapértelmezetten a PyQt nem tartalmaz ilyen típusú előredefiniált osztályt, ezért ezt külön le kellett implementálni. A SelectableGraphicsView a QGraphicsView beépített PyQt osztályból származik. Ez azért került választásra mivel a QGraphicsView alkalmas bármiféle statikus grafikus elem beágyazására és ugyanakkor egy olyan területet kínál ami, ha nem fér ki teljesen a képernyőn, akkor scroll-ozni lehet. A SelectableGrahicsView biztosítja, hogy az alkalmazás futásának minden pillanatában egy stílus ki van jelölve. A felhasználó váltogathat ezen stílusok között. A SelectableGraphicsView típusú objektum minden váltogatás esetében jelzést fog küldeni a MainWindow objektumnak, ami lementi azt, hogy az épp kijelölt stílus bemeneti stílus képek a merev lemezen hol talalható.
\newline
\indent
A főablak egyik fontos objektuma a Worker típusú objektum. Ez a típus a QThread beépített osztály leszármazottja, ami a párhuzamosításért felelős. A Worker típusú objektum felüldefiniálja a QThread run metódusát ami külön szálon fog majd lefutni. Ebben a metódusban lesz létrehozva az ArtisticVideo objektum ami a stílusátruházást végzi. Kezdetben a Worker objektumot a MainWindow inicializálja, az inicializálás még a főszálon történik. Miután ez megtörtént, a főablakon levő "Start" nyomógomb lenyomásával, meghívódik a run metódus. A Worker objektum kapcsolatban áll a MainWindow és a ProgressBar típusú objektumokkal is, amiknek különféle jelzéseket tud küldeni (work\_started, work\_finised, show\_progress, display\_image).
\newline
\indent
Ugyancsak a MainWindow tartalmazza a ProgressBar létrehozásával felelős factory típusú metódust. Amint emlitettem, a felhasználó "Browse..." lenyomásával beolvashat statikus képet vagy mozgó kép típusú fájlt. Ezekre az átruházás különböző folyamatokat vesznek igénybe. Ahhoz, hogy a felhasználó részletesebb tájékoztatást kapjon arról, hogy mi folyik a háttérben, ezért három típusú progress sávval rendelkező dialogus ablakot implementáltunk le, amik egy közös ősosztállyal rendelkeznek.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.35]{main_ui.png}
		\caption{A rendszer felhasználói felülete}
		\label{graphical_ui)}
	\end{center}
\end{figure}

\begin{figure}[!htbp]
	\centering
	\subfloat[Aba Novak Vilmos - Önarckép]{
		\includegraphics[width=40mm]{aba_novak_vilmos_onarckep.jpg}
	}
	\subfloat[Aba Novak Vilmos - Selfportrait]{
		\includegraphics[width=40mm]{aba-novak_vilmos_selfportrait.jpg}
	}
	\subfloat[Csontvary Kosztka Tivadar - Traui tájkép naplemente idején]{
		\includegraphics[width=40mm]{csontvary_kosztka_tivadar_traui_tajkep_naplemente_idejen.jpg}
	}
	\hspace{0mm}
	\subfloat[Iványi Grunwald Béla - Parkrészlet Kecskeméten]{
		\includegraphics[width=40mm]{ivanyi_grunwald_bela_parkreszlet_kecskemeten.jpg}
	}
	\subfloat[Munkácsi Mihály - Vihar a pusztán]{
		\includegraphics[width=40mm]{munkacsi_mihaly_vihar_a_pusztan}
	}
	\subfloat[Réti Alfréd]{
		\includegraphics[width=40mm]{reti_alfred.jpg}
	}
	\hspace{0mm}
	\subfloat[Ripl-Rónai József - Apám és Piacsek bácsi vörösbor mellett]{
		\includegraphics[width=40mm]{ripl_ronai_jozsef_apam_es_piacsek_bacsi_vorosbor_mellett.jpg}
	}
	\subfloat[Tihanyi Tzara]{
		\includegraphics[width=40mm]{tihanyi_tzara.jpg}
	}
	\subfloat[Magyar Népmesék]{
		\includegraphics[width=40mm]{magyar_nepmesek.jpg}
	}
	\caption{Stílusképek}
	\label{styles}
\end{figure}

\subsubsection{A beállítások (Settings) komponens implementálása}
\sssecro{Implementarea componentei Settings}
\sssecen{The implementation of the Settings component}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.7]{preferences.png}
		\caption{A beállítások komponens osztálydiagrammja}
		\label{preferences_class}
	\end{center}
\end{figure}

A bellítások komponens két objektumot tartalmaz, egyik a PreferencesDialog típusú objektum és az ebbe beágyazott nézetért felelős UiPreferencesDialog objektum. Értelemszerűen a PreferencesDialog tartalmazza a működési logikát.
\newline
\indent
A PreferencesDialog a beépített QDialog osztály leszármazottja, örökli ennek tulajdonságait. Szülő objektumként természetesen a MainWindow objektumot kapja meg, ami Qt-ben annyit jelent, hogy ha a szülő objektum elhal, akkor fel fogja szabadítani a gyerek objektumot is, tehát valójában a szülő objektum felelős a gyerek objektum életciklusáért.
A beállítások dialogus két tab-ot tartalmaz:

\begin{itemize}
	\item Settings: itt meg lehet adni a foldert ahova a kimenet automatikus mentve lesz. Ugyanitt meg kell adni az előre betanított háló útvonalát.
	\item Advanced Settings: it a tanítással kapcsolator paramétereket lehet szabályozni. Ilyen paraméterek:
	\begin{itemize}
		\item Learning rate - tanítási együttható 
		\item Iteration per Frame - egy adott képkocka esetében a maximálos tanítási iterációk száma;
		\item Content Weight - súlyzó, a bemeneti kép veszteségfüggvénye esetében használatos;
		\item Style Weight - súlyzó, a stílus veszteségfüggvényének az együtthatója;
		\item Temporal Weight - súlyzó, a mozgóképek esetében bevezetett veszteségfüggvény együtthatója.
		\item Use deep flow - egy flag-et állít, ezzel kikapcsolható az időigényes deep flow módszer használata, cserébe gyengébb minőségű videó lesz az eredmény. 
	\end{itemize}
\end{itemize}

Az beállítások komponens tárolja az előre megadott (default) értékeket a paraméterek esetében, ugyanakkor az is el lesz tárolva amit felhasználó módosít ezeken. A módosított értékek megmaradnak akkor is ha az alkalmazást bezárjuk majd újraindítjuk. Erre beéppített QSettings objektum használtuk, ami megoldja az beállítások tárolását és vissaolvasását. A QSettings kulcs-érték táblákba tárolja az paramétereket. Ezek majd az aplikációnk bármelyik objektumából elérhetőek, ha példányosítjuk a QSettings osztályt és megadjuk az adatbázisunk nevét ahova a paraméterek mentve lettek.
\newline
\indent
Az alapértelmezett beállítások bármikor visszállíthatóak a "Use default values" gomb lenyomásával ugyanis ezek a paraméterek hardcode-olva vannak az aplikáción belül.

\begin{figure}[!htbp]
	\centering
	\subfloat[Settings tab]{
		\includegraphics[width=65mm]{settings.png}
	}
	\subfloat[Advanced Settings tab]{
		\includegraphics[width=65mm]{advanced_settings.png}
	}
	\caption{Beállítások dialogus ablak}
	\label{settings_dialog}
\end{figure}

\subsubsection{A progress sáv (Progress bar) komponens implementálása}
\sssecro{Implementarea componentei Progress bar}
\sssecen{The implementation of the Progress bar component}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.65]{progressbar.png}
		\caption{A progress sáv komponens osztálydiagrammja}
		\label{progressbar_class}
	\end{center}
\end{figure}

A progress sáv komponens feladata kimutatni a felhasználó számára a hátrelevő munkamennyiséget. Statikus képek esetében kimutatásre kerül az, hogy az össziterációk számának hány százaléke volt elvégezve. Mozgóképek esetén emellett kimutatásre kerül, hogy a képkockák közül hány százalékre volt stílus átruházva az összes képkockákból. Ha deep flow metódus is használatra kerül, akkor ennek is egy külön sáv fogja valós időben kijelezni, hogy hány képkocka van még hátra amire alkalmazni kell a deep flow metódust. Ezekből következtethető, hogy három típusú ProgressBar osztály példányosítható, amelyek az alábbiak:

\begin{itemize}
	\item ProgressBarImage(\ref{progressbar_image_ui}. ábra)
	\item ProgressBarVideo(\ref{progressbar_video_no_deeplfow_ui}. ábra)
	\item ProgressBarVideoOpticalFlow (\ref{progressbar_video_deeplfow_ui}. ábra)
\end{itemize}

Mind a három egy közös ősosztályból öröklődik, ez a sima ProgressBar osztály. A ProgressBar osztály a beépített QDialog-ból öröklődik. A QDialog előnye, hogy be meg lehet határozni, hogy amikor a dialogus ablak fókuszban van, akkor ne lehessen interakciónálni a szűlő osztály interfészével. Ez fontos aspektus, mivel amikor maga a stílus átruházás történik, akkor nem szeretnénk, ha a felhasználó a fő ablakkal interakciónáljon, esetlegesen egy másik átruházási folyamatot indítson. Ez az aplikáció összeomlásához vezetne.
\newline
\indent
Ahogyan már a MainWindow esetében is bemutatásra került, a ProgressBar típusú osztályok létrehozása a factory modell segítségével történik. Az hogy melyiket fogjuk példányosítani, az a bemeneti állomány típúsától, valamint a beállításoktól függ. A ProgressBar ősosztály SLOT metódust tartalmat a "Cancel\textbackslash OK" nyomógomb lekezelésére, és a státus üzenet kiíratására, amit a többi származtatott osztály is örökölni fog. 
A videóval kapcsolatos ablakok emellet SLOT függvényeket definiálnak annak érdekében, hogy ki tudják jelezni hány képkocka van még hátra.

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.5]{progressbar_image.png}
		\caption{Progress sáv statikus kép esetében}
		\label{progressbar_image_ui}
	\end{center}
\end{figure}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.5]{progressbar_video_no_deepflow.png}
		\caption{Progress sáv videó esetében (deepflow kikapcsolva)}
		\label{progressbar_video_no_deeplfow_ui}
	\end{center}
\end{figure}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.5]{progressbar_video_deepflow.png}
		\caption{Progress sáv videó esetében (deepflow bekapcsolva)}
		\label{progressbar_video_deeplfow_ui}
	\end{center}
\end{figure}

\subsubsection{A stílusátruházó (Artistic video creator) komponens impementálása}
\sssecro{Implementarea componentei Artistic video creator}
\sssecen{The implementation of the Artistic video creatorr component}

\begin{figure}[!htbp]
	\begin{center}
		\includegraphics[scale=0.65]{artisticvideo.png}
		\caption{A stílusátruházó (Artistic video creator) komponens osztálydiagrammja}
		\label{artisticvideo_class}
	\end{center}
\end{figure}

A stílusátrhuzázó komponenst az ArtisticVideo, VGG19 és AtomBoolean osztályok alkotják (\ref{artisticvideo_class}. ábra). Ezek körül az ArtisticVideo osztály felelől a stílus átruházásával, a VGG19 osztály felelős az előredefiniált neuronháló beolvasásával. Az AtomBoolean egy segítő osztály, több szálról is módosítható flag-et definiál. Ezek mellett komponens még használ két csoport segítőfüggvényt amikot az Image meg a Video állományokba csoporosítottunk.
\newline
\indent
Az ArtisticVideo osztályt a Worker objektum példányosítja. Mivel a Worker objektumunk a mellákszálöóon fut, ezzért az ArtisticVideo objektumunk metódusai is a mellékszálon fognak elvégződni. Az ArtisicVideo-nak két fontos metódusa a create\_image és a stylize. A create\_image megkapja a bemenet útvonalát, amit az Image vagy Video segítő függvénycsomagok segítségével beolvas és feldolgoz. Amiután ez megtörtént, egyenként minden képkockára meghívódik a stylize metódus. A stylize metódus tartalmazza a tanítási algoritmus. Ennek a függvény eredménye minden esetben egy stilizált kép, kivételes eset, ha a tanítás megszakad, ekkor a visszatérített érték a null (None). Ugyancsak a create\_image metódusra hárul a képkockákból videót alkotni. 
\newline
\indent
Az ArtisticVideo jelzéseket küld a főablak és a progress dialógus komponenseknek. A Qt kimondja, hogy a felhasználói felület mindenképpen a fő szálon kell fusson ezért az ArtisticVideo nem oldhatja meg az, hogy függvényhívással módosítja a felhasználói felületet. Ez mindenképp jelzéssel kell megoldani, kikötve azt, hogy a jelzésre válaszoló függvény a fő szálon fut. Az ArtisticVideo osztály által definiált jelzések:

\begin{itemize}
	\item flow\_created: akkor bocsájtódik ki amikor egy adott képkocka esetében a deep flow eljárás lefutott. Csak mozgóképek esetében bocsájtódik ki;
	\item frame\_changed: akkor küldődik, amikor egy képkockára sikeresen át lett ruházva a stílus;
	\item iter\_changed: egy kép esetében minden eltelt tanítási iteráció esetén kibocsájtódik;
	\item set\_status: a progress dialógs ablakon levő státus üzenetet lehet állítani ezzel.
\end{itemize}

A VGG19 osztály a bemeneti hálót parszolja és felépíti az alkalmazásban használatos hálót. Mivel a háló mérete nagy (549MB), ezért a merevlemezről törénő beolvasás egyszer történik. A háló a memóriában marad amig szükség van erre. Ennek hátránya a memória foglalása, de ekkora memóriahasználat modern számítógépek esetében nem jelent gondot.
\newline
\indent
Ugyanehhez a komponenshez sorolhatunk két segítő (utility) függvéyneket tartalmaza csomagot: az egyik csoport az Image, a másik a Video névre hallgat.
\newline
\indent
Az Image csomag tartalmaz egy imread függvényt statikus kép beolvasására és egy imwrite függvényt statikus kép mentésére. Beolvasáskor preprocesszálás történik a bemeneti adaton, ami azt jelenti, hogy a színcsatornákból kivonódnak a következő középértékek: [123.68, 116.779, 103.939]. Ez arra szolgál, a hogy a pixelértékek 0-ás körüli értékeket vegyenek fel. Mentéskör ezek az értékeket hozzádajuk a kimeneti kép színcsatornáihoz.
\newline
\indent
A Video csomag tartalmaz egy convert\_to\_frames függvényt ami a megadott útvonalon levő videót képkockákká alakítja. Ezeket a képkockákat majd az imread-del fogjuk feldolgozni. Emellett tartalmazza a convert\_to\_video függvényt, ami a kimentett képsorozazoz fogja videóvá alakítani. Továbbá tartalmazza a make\_opt\_flow és \_run\_consistency\_check függvényeket, amik az optical flow és képkockák mozgási határait eredményezik. Mindkét esetben a függvény egy külső bináris állomány futtatásával végzi el a feladatot. Ezek a binárisok nem saját programkódok a készítők lefordított állományait használtuk fel\cite{34}.

%----------------------------------------------------------------
\chapter{A rendszer tesztelése}
\capterro{Testarea sistemului}
\capteren{The testing of the system}

testing

%----------------------------------------------------------------
\chapter{Összefoglaló}
\capterro{Concluzie}
\capteren{Conclusion}

összefoglaló

% Ábrajegyzék
%---------------------------------
\newpage
 \listoffigures


% thebibliography
%---------------------------------
\newpage
\begin{thebibliography}{1}

\bibitem {1}
Krizhevsky, A., Sutskever, I., and Hinton, G. E. ImageNet classification with deep convolutional neural networks (2012)

\bibitem{2}
Zeiler, M. D. and Fergus, R. Visualizing and understanding convolutional networks (2013)

\bibitem{3}
\url {https://en.wikipedia.org/wiki/CUDA} (2017.04.24)

\bibitem{4}
\url {http://caffe.berkeleyvision.org} (2017.04.24)

\bibitem{5}
\url {https://keras.io/} (2017.04.24)

\bibitem{6}
\url {http://deeplearning.net/software/theano/} (2017.04.24)

\bibitem{7}
\url {https://www.tensorflow.org/} (2017.04.24)

\bibitem{8}
\url {http://torch.ch/} (2017.04.24)

\bibitem{9}
\url {https://computerstories.net/microsoft-computer-outperforms-human-image-recognition-12028} (2017.04.29)

\bibitem{10}
Kevin Alfianto, Mei-Chen Yeh, Kai-Lung Hua - Artist-based Classification via Deep Learning with Multi-scale Weighted Pooling (2016)

\bibitem{11}
Rosenblatt F. - The Perceptron: A Probabilistic Model For Information Storage And Organization In The Brain (1958)

\bibitem{12}
Werbos, P.J. - Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences (1975)
 
\bibitem{13}
LeCun, Yann, Léon Bottou, Yoshua Bengio, Patrick Haffner - Gradient-based learning applied to document recognition (1998)

\bibitem{14}
Dave Steinkraus, Patrice Simard. Ian Buck - Using GPUs for Machine Learning Algorithms (2005)

\bibitem{15}
Gatys, L. A., Ecker, A. S., Bethge - A neural algorithm of artistic style (2015)

\bibitem{16}
Yaroslav Nikulin, Roman Novak - Exploring the Neural Algorithm of Artistic Style (2016)

\bibitem{17}
Justin Johnson, Alexandre Alahi, Li Fei-Fei - Perceptual Losses for Real-Time Style Transfer and Super-Resolution

\bibitem{18}
Ulyanov, D., Lebedev, V., Vedaldi, A., and Lempitsky - Texture networks: Feed-forward synthesis of textures and stylized images

\bibitem{19}
Ulyanov, D., Lebedev, V., Vedaldi, A., and Lempitsky - Instance Normalization: The Missing Ingredient for Fast Stylization

\bibitem{20}
\url{https://en.wikipedia.org/wiki/Prisma_(app)} (2017.04.29)

\bibitem{21}
Manuel Ruder, Alexey Dosovitskiy, Thomas Brox - Artistic style transfer for videos (2016)

\bibitem{22}
asd

\bibitem{23}
\url{https://www.python.org/} (2017.04.30)

\bibitem{24}
\url{http://www.numpy.org/} (2017.04.30)

\bibitem{25}
\url{https://www.riverbankcomputing.com/software/pyqt/intro} (2017.04.30)

\bibitem{26}
\url{http://opencv.org/} (2017.04.30)

\bibitem{27}
Gatys, L. A., Ecker, A. S., Bethge, M. Texture synthesis and the controlled generation of natural stimuli using convolutional neural networks (2015)

\bibitem{28}
\url{https://research.googleblog.com/2015/06/inceptionism-going-deeper-into-neural.html} (2017.05.01)

\bibitem{29}
Simonyan, K., Zisserman, A. - Very Deep Convolutional Networks for Large-Scale ImageRecognition (2015)

\bibitem{30}
\url{http://mathworld.wolfram.com/GramMatrix.html} (2017.05.02)

\bibitem{31}
\url{https://en.wikipedia.org/wiki/Total_variation_denoising} (2017.05.03)

\bibitem{32}
Kingma D. P., Lei Ba, J. - ADAM: A method for stochastic optimization (2015)

\bibitem{33}
\url{http://caffe.berkeleyvision.org/tutorial/solver.html} (2017.05.14)

\bibitem{34}
\url{https://www.mathworks.com/discovery/optical-flow.html} (2017.05.18)

\bibitem{35}
Martin Abadi, Ashish Agarwal, Paul Barham, Eugene Brevdo, Zhifeng Chen, Craig Citro, Greg S. Corrado, Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghemawat, Ian Goodfellow, Andrew Harp, Geoffrey Irving, Michael Isard, Yangqing Jia, Rafal Jozefowicz, Lukasz Kaiser, Manjunath Kudlur, Josh Levenberg, Dan Mane, Rajat Monga, Sherry Moore, Derek Murray, Chris Olah, Mike Schuster, Jonathon Shlens, Benoit Steiner, Ilya Sutskever, Kunal Talwar, Paul Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda Viegas, Oriol Vinyals, Pete Warden, Martin Wattenberg, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng - TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems (2015)


\end{thebibliography}

\end{document}
